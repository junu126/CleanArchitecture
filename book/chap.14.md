# Chap.14 컴포넌트 결합

## ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

하나의 소스코드에서 여러 사람이 작업하다보면 서로의 코드에 의존성이 생기게 된다. 만약 A가 작성한 코드가 B에 의존하는데, 정상적이게 작동하고 있다. 이때 B가 코드를 수정하게 되면, A의 코드는 작동하지 않을 것 이다.

이런 문제의 해결책으로 두 가지 방법이 있다.

* 주 단위 빌드
* 의존성 비순환 원칙

### 주 단위 빌드

* 중간 규모 프로젝트에서 사용
* 일주일의 4일을 개인적으로 코딩하고 단 하루에 모든 빌드를 몰아서 한다.
* 장점
  * 빠른 피드백
  * 편안한 개발
* 단전
  * 프로젝트 구조가 커지면 장점이 무용지물.
  * 통합\(통합 빌드\)에 드는 시간이 길고 어려움.
  * 통합에 드는 시간이 길면 효율이 떨어짐

### 순환 의존성 제거하기

주 단위 빌드의 해결책은 **개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것**이다.

* 하지만 해당 절차가 성공하려면 `컴포넌트 사이의 의존성 구조`를 반드시 관리해야 한다.
* 컴포넌트 구성요소 사이의 의존성을 파악하고 있으면 _**시스템을 빌드하는 방법과 순서**_를 알 수 있다.

### 순환이 컴포넌트 의존성 그래프에 미치는 영향

* 의존성 그래프에 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워 진다.
* 단위 테스트를 하고 릴리스를 하는 일이 괸장히 어려워지며, 에러도 쉽게 발생한다.
* 모듈의 개수가 많아 짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.

### 순환 끊기

컴포넌트 사이의 순환을 끊고 의존성을 다시 `DAG`로 원상복구하는 일은 언제라도 가능하다.

1. **`의존성 역전 원칙`**

   `DIP`를 이용하여 의존성을 역전 시킨다.

2. **`컴포넌트 사이의 순환이 되는 컴포넌트들이 모두 의존하는 새로운 컴포넌트를 만든다.`**

   두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

### 흐트러짐\(Jitters\)

**순환끊기**의 두번째 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실이다. 그리고 순환이 발생하면 어떤 식으로든 끊어야 한다.

**때론 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수도 있다.**

## 하향식\(top-down\) 설계

* 컴포넌트 구조는 하향식으로 설계될 수 없다.
  * 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.
* 의존성 구조와 관련된 최우선 관심사는 `변동성`을 격리하는 일이다.
* 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이다.
* 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.

## SDP: 안정된 의존성 원칙

> 안정성의 방향으로 \(더 안정된 쪽에\) 의존하라

* 변동성을 지니도록 설계환 컴포넌트는 언제가 변경된다.
* 의존성을 갖는 컴포넌트는 변경하기 어렵다.
* _**안정된 의존성 원칙**_을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

### 안정성

무언가가 안정적이라는 말을 `웹스터` 사전에서는 **'쉡게 움직이지 않는'**이라고 정의한다.

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법은 **수 많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.**

### 안정성 지표

다음은 안정성 지표이다.

* _**Fan-in**_: 안으로 들어오는 의존성.
* _**Fan-out**_: 바깥으로 나가는 의존성
* _**I\(불안정성\)**_: I = Fan-out / \(Fan-in + Fan-out\) I=1 이면 최고로 불안정한 컴포넌트이다.

SDP에서 컴포넌트의 I지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야 한다고 말한다.

_**즉, 의존성 방향으로 갈수록 I 지표 값이 감소 해야한다.**_

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다.

만약 모든 컴포넌트가 최고로 안정적인 시스템이라면 **변경이 불가능하다.**

이는 바람직한 상황이 아니다.

### 추상 컴포넌트

오로지 인터페이스만을 포함하는 컴포넌트를 생성하는 방식으로 추상 컴포넌트를 활성화 시킨다.

이로 인해 의존성을 관리할 수 있다.

## SAP: 안정된 추상화 원칙

> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

### 고수준 정책을 어디에 위치시켜야 하는가?

시스템에는 자주 변경해서는 절대로 안 되는 소프트웨어도 있다. **고수준 아키텍처나 정책 결정과 관련된 소프트웨어가 그 예다.** 이들은 안정된 컴포넌트\(_**I**_ = 0\)에 위치해야한다.

하지만 안정된 컴포넌트에 위치시키면, 정책을 포함하는 소스 코드는 수정하기가 어려워진다. 그리고 이로인해 시스템 전체가 유연성을 잃는다.

그렇다면 컴포넌트가 안정 상태이면서 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들려면 어떻게 해야하는가.

해답은 `개방 폐쇄 원칙`에서 찾을 수 있다.

### 안정된 추상화 원칙

_**안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.**_

* 안정된 컴포넌트는 `추상 컴포넌트`여야 하며  컴포넌트 확장을 방해하면 안된다.
* 불안정한 컴포넌트는 반드시 `구체 컴포넌트`여야 하며 컴포넌트 내부의 코드를 쉽게 변경할 수 있어야 한다.

즉, _**안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.**_

### 추상화 정도 측정하기

다음은 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산한 값

* _**NC**_: 컴포넌트의 클래스 개수
* _**Na**_: 컴포넌트의 추상클래스와 인터페이스의 개수
* _**A**_: 추상화 정도. A = Na / Nc \(0이면 추상 클래스가 한개도 없고, 1이면 오로지 추상클래스만 있다.\)

### 주계열

안정성과 추상화 정도의 비율이 1:1 또는 0:0이 될 수록 **배제 구역**에 들어간다. 0:1 또는 1:0이 될 수록 주계열에 들어간다.

1:1이 되면 **쓸모없는 구역\(Zone of Uselessness\)**으로 할당되고 0:0이 되면 **고통의 구역\(Zone of Pain\)**으로 할당된다.

### 고통의 구역

\(0, 0\) 주변 구역의 컴포넌트는 매우 안정적이며 구체적이다. **뻣뻣한 상태**라고 할 수 있다. 추상적이지 않아서 확장할 수 없고, 안정적이므로 변경하기 상당히 어렵다.

하지만 변동성이 없는 컴포넌트는 \(0, 0\) 구역에 위치하더라도 해롭지 않다. 변동될 가능성이 없기 때문이다.

### 쓸모없는 구역

\(1, 1\) 주변의 컴포넌트는 최고로 추상적이지만, 누구도 그 컴포넌트에 의존하지 않는다. **쓸모없는 상태**라고 할 수 잇다.

### 배제 구역 벗어나기

* 변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 한 멀리 떨어뜨려야한다.
* 주계열에 위치하도록 해야하며, **'너무 추상적'**이지도 않고, **'너무 불안정'**하지도 않아야 한다.

### 주계열과의 거리

주 계열에서 멀리 벗어난 원인을 파악하고 조사하는 것이 중요하다.

## 결론

의존성 관리 지표는 설계의 의존성과 추상화 정도가 **저자가 '훌륭한 패턴'이라고 생각하는 수준**에 얼마나 잘 부합하는지를 측정한다.

* 좋은 의존성도 있지만, 좋지 않은 의존성도 있다.

