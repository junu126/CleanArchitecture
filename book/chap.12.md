# Chap.12 컴포넌트

`컴포넌트`: 모든 언어에선 배포 단위. \(ex. 자바의 경우는 jar파일\)

* 컴파일형 언어에선 **바이너리 파일의 결합체**
* 인터프리터형 언어에선 **소스 파일의 결합체**

컴포넌트가 어떻게 배포되든, _**잘 설계된 컴포넌트라면 반드시 독립적으로 배포가**_ 가능해야한다.

## 컴포넌트의 간략한 역사

* 프로그래밍 초창기에는 프로그램을 로드할 메모리의 위치를 반드시 코드에서 표기해야 했다.
* 그리고 이러한 특징 때문에 라이브러리에 접근하기가 힘들었다.
* 그래서 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켰다. → 단일 프로그램으로 컴파일
  * 컴파일 과정은 오래 걸리고 메모리는 부족했다.
* 이를 보완하기 위해 함수 라이브러리의 소스 코드를 애플리케이션과 분리하고 따로 컴파일 한다.
* 이후 라이브러리의 메모리 주소에 접근하는 방법으로 라이브러리를 사용했다.
* 하지만 애플리케이션이 커지면서 필요한 메모리의 양이 늘어났다. 그리하여 이와 같은 방식이 잘 동작하지 못했다.

## 재배치성

이들은 지능적인 로더를 이용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 방법으로 메모리문제를 해결할 수 있었다.

* 프로그램이 라이브러리 함수를 호출하면 라이브러리 함수 이름을 `외부 참조`로 생성했다.
* 라이브러리 함수를 정의하는 프로그램이면 해당 이름을 `외부 정의`로 생성했다.
* 이런 방식으로 정의를 로드할 위치만 정해지면 로더가 참조와 정의를 링크 시킬 수 있었다.
* 이러한 방식을 `링킹 로더`라고 한다.

## 링커

링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 된다.

* 하지만 1970대 초가 되자 프로그램이 많이 커지게 된다. 결국 링킹 로더가 너무 느려서 이를 분리한다.
* 프로그래머가 링크의 과정을 맡아서 `링커`라는 별도의 애플리케이션으로 해당 작업을 수행한다.

약간의 해결책을 통해 메모리 문제를 해결하고 시대는 급격히 변화하여 컴퓨터 메모리는 말도 안 될 정도로 저렴해졌다. 그리고 1990년대 후반이 되면서 `액티브X`와 공유 라이브러리 시대가 열렸다.

## 결론

* 과거에는 초인적인 노력을 들여야만 컴포넌트 플러그인 아키텍처를 적용할 수 있었다.
* 현재는 기본으로 쉽게 사용할 수 있는 지점까지 다다랐다.

즉, 아키텍처를 활용해야 한다.

