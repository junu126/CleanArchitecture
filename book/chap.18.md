# Chap.18 경계 해부학

시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.

그리고 다양한 형태로 나타난다.

## 경계 횡단하기

* 적절한 위치에서 경계를 횡단하게 하는 비결은 `소스 코드 의존성 관리`에 있다.
* 왜냐하면 소스 코드 모듈 하나가 변경되면, 이에 의존하는 다른 소스 코드 모듈들도 변하거나 다시 컴파일해서 새배포해야 할 수도 있기 때문. → **경계**: 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단.

## 두려운 단일체

**단일체\(monolith\):** 단일 실행 파일 \(.jar파일로 묶인 자바 클래스 파일, c++프로젝트 등.\)

* 단일체는 배포 관점에서 보면 경계가 드러나지 않는다.
* 다양한 컴포넌트가 독립적으로 수행할 수 있게 하는 일은 대단히 가치 있는 일이다. \(단일체의 경계 구분\)

`가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.`

* 런타임 의존성과 컴파일타임 의존성을 모두 같은 방향으로 향하게 할 수 있다. → **즉, 저수준에서 고수준 컴포넌트로 향한다.**
* EX\) `typescript`뷰 파일 \(tsx\)에서 `model.ts` 에서 remote타입을 불러오고 `remote.ts`에서 remote함수를 불러올 때, `tsx파일`은 저수준의 컴포넌트이고, 모델과 리모트함수는 고수준 컴포넌트이다.
* 반대로 고수준에서 저수준 서비스를 호출해야할 때에는 의존성 역전을 이용한다.

## 배포형 컴포넌트

* 아키텍처의 경계가 물리적으로 드러날 수 있는데 가장 단순한 형태는 동적 링크 라이브러리다. \(npm, yarn workspace 등..\)
* 컴포넌트를 `DNL (dinamic link library)`로 배포하면 따로 컴파일 하지 않고 곧바로 사용할 수 있다.
* 하지만 배포과정에서 **배포 수준 결합 분리 모드로** 경계를 나눠야 한다
* 매우 값싸고 경계를 횡단 할 수 있게 된다.

## 스레드

모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 많은 컴포넌트에 걸쳐 분산될 수 있다.

## 로컬 프로세스

훨씬 강한 물리적 형태를 띠는 아키텍처 경계로 **로컬프로세스**가 있다.

* 명령행 \(terminal\)이나 유사 시스템 호출로 생성됨.
* 로컬프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다.
* 항상 고수준 컴포넌트를 향한다.

## 서비스

`물리적인 형태를 띠는 가장 강력한 경계는 서비스이다.`

* 프로세스로, 명령행 또는 그와 동등한 시스템 호출로 구동됨.
* 자신의 물리적위치에 구애받지 않음.
* 모든 통신이 네트워크를 통해 이뤄진다고 가정함.

## 결론

단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.

**실제로 서비스는 상호작용하는 일련의 로컬 프로세스 퍼사드\(Facade\)에 불과할 때가 많다.**

즉, 대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있다.

