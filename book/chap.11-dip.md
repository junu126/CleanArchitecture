# Chap.11 DIP: 의존성 역전 원칙

* 의존성 역전 원칙에서 말하는 **유연성이 극대화된 시스템**이란, `소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템`이다.

## 안정된 추상화

* 추상 인터페이스에 변경이 생기면  이를 구체화한 구현체도 따라서 수정해야 한다.
* 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 대다수의 경우 변경될 필요가 없다.
* 즉, _**인터페이스는 구현체보다 변동성이 낮다.**_

### DIP에서 전달하려는 코딩 실천법

1. **변동성이 큰 구체 클래스를 참조하지 말라.**
   * 대신 추상 인터페이스를 참조하라.
   * 추상 팩토리를 사용하도록 강제함.
2. **변동성이 큰 구체 클래스로부터 파생하지 말라.**
   * 동적 타입 언어는 클래스 상속에서 의존성을 갖게 되므로 신중하게 결정하라.
   * 더불어서, 정적 타입언어도 마찬가지지만 더욱 소스 코드에 존재하는 모든 관계 중 가장 강력한 동시에 뻣뻣해서 변경하기 어려우므로 신중을 거듭해야한다.
3. **구체 함수를 오버라이드 하지 말라.**
   * 구체 함수는 소스 코드 의존성을 필요로 한다.
   * 의존성 제거를 위해선 추상 함수로 선언하고 구현체에서 각자의 용도에 맞게 구현해야한다.
4. **구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.**
   * 해당 실천법은 `DIP 원칙`을 다른 방식으로 풀어쓴 것 이다.

## 팩토리

* 의존성의 제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다.
* 여기서 곡선은 추상 컴포넌트와 구체 컴포넌트를 나누는 분기점이다.
* 즉. _**소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다. → 의존성 역전**_

## 구체 컴포넌트

책의 저자는 구체 컴포넌트에는 구체적인 의존성이 없어야 한다고 말헀다. 하지만 이는 위배될 수 밖에 없다. 하지만 이는 **일반적인 일이다.**

* 이러한 구체 컴포넌트를 흔히 `Main`이라고 부른다.

## 결론

DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이다.

* 아키텍처 경계를 기준으로 더 추상적인 엔티티가 있는 쪽으로 의존성이 향한다.
* 그리고 이 규칙을 `의존성 규칙`이라 부른다.

